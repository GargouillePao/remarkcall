<h1 style="line-height: 1;"><span style="line-height: 1;">Map Reduce </span><label class="label label-info">粗译</label>&nbsp;</h1><p>&nbsp;</p><h3 id="context0at1456905582">1.介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在过去的5年里，作者们和其他在Google工作的同事实现了上百个处理大量原始数据（爬虫文件，网页请求日志等等）的专用机器，用来计算多种派生数据，比如倒排索引，网页的多种图型表示，在特定一天大量频繁的请求。大多数这样的计算概念上都很明确。然而，输入的数据通常很大，不得不将计算分布到成百上千的电脑上才能在合适的时间内完成。怎样并行计算，分布式数据，处理失误，这些问题使得本来简单的问题变得模糊不清。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;为此，我们设计了一个新的抽象库，可以允许我们完成容易的分布式运算，这个库尽量做到高性能的同时隐藏并行运算，容错，数据分布式和负载均衡的复杂性。我们的灵感源自以Lisp和其他很多函数式语言为代表的map、reduce原型。我们发现，多数计算都包括对我们输入的每个“逻辑记号”使用map操作，以便生成一个中间键值对集合，之后对每个共享相同键的值使用reduce操作，以便于合理的组合派生数据。我们使用带有用户指定的map和reduce操作的函数模型轻松地进行大规模并行计算，使用再执行为原型进行容错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这次任务主要的贡献是一个简单又有力的接口，它能够自动地进行大规模分布式并行计算，与其实现相结合可以高效地完成大量PC机并行计算。</p><h3 id="context1at1456905582">2.程序模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;计算通过一个输入键值对集合生成一个输出键值对集合，MapReduce库将其表示为两个函数：Map和Reduce。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;用户编写Map时，通过输入键值对生成中间键值对，MapReduce库把所有拥有相同键I的值打组后传递给Reduce函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;用户编写Reduce时，接收键I以及它的值，把这些值混合成一个尽可能小的集合。通常每次调用Reduce只会生成0个或者1个值。提供给用户Reduce函数的这些中间值集合的是一个迭代器。它允许我们处理那些超过内存大小的列表数据。</p><h4>2.1 例子</h4><p>&nbsp; &nbsp; 考虑一个计算在一个文档的大集合里面出现每一个词的数量问题，用户只要轻松的写如下伪代码：</p><pre class="line-numbers  language-pseudo"><code class="  language-pseudo">map(String key,String value):<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">  // key: document  name<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">  // value: document contents <span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">  for each word w in value:<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">    EmitIntermediate(w,"1");<span class="line-numbers-rows"><span></span></span></code></pre><p><br></p><pre class="line-numbers  language-pseudo"><code class="  language-pseudo">reduce(String key, Iterator values):<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> // key: a word<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> // values: a list of counts<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> int result = 0;<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> for each v in values:<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">   result += ParseInt(v);<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> Emit(AsString(result));<span class="line-numbers-rows"><span></span></span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;map函数发送每一个word加上一个与之相连的数字（例子中给的是1）。reduce函数合计所有发射来的数字。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;另外，用户把输入和输出文件的名字也写进代码，之后调用MapReduce函数，传入一个专用的对象，用户的代码就与MapReduce库链接在了一起。附录A带有所有代码示例。</p><h4>2.2 类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;即使之前的伪代码是一个字符串的输入输出模式，讲道理给用户提供的map和reduce函数具有相关的类型：</p><p>&nbsp; &nbsp; map (k1, v1)&nbsp;&nbsp;&nbsp;&nbsp;-&gt; list (k2, v2)</p><p>&nbsp; &nbsp; reduce (k2, list(v2))&nbsp; &nbsp; -&gt; list (v2)</p><p>3213</p><p></p>