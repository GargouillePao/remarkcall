<h1 style="line-height: 1;"><span style="line-height: 1;">Map Reduce </span><label class="label label-info">粗译</label>&nbsp;</h1><p>&nbsp;</p><h3 id="context0at1457005060">1.介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在过去的5年里，作者们和其他在Google工作的同事实现了上百个处理大量原始数据（爬虫文件，网页请求日志等等）的专用机器，用来计算多种派生数据，比如倒排索引，网页的多种图型表示，在特定一天大量频繁的请求。大多数这样的计算概念上都很明确。然而，输入的数据通常很大，不得不将计算分布到成百上千的电脑上才能在合适的时间内完成。怎样并行计算，分布式数据，处理失误，这些问题使得本来简单的问题变得模糊不清。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;为此，我们设计了一个新的抽象库，可以允许我们完成容易的分布式运算，这个库尽量做到高性能的同时隐藏并行运算，容错，数据分布式和负载均衡的复杂性。我们的灵感源自以Lisp和其他很多函数式语言为代表的map、reduce原型。我们发现，多数计算都包括对我们输入的每个“逻辑记号”使用map操作，以便生成一个中间键值对集合，之后对每个共享相同键的值使用reduce操作，以便于合理的组合派生数据。我们使用带有用户指定的map和reduce操作的函数模型轻松地进行大规模并行计算，使用再执行为原型进行容错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这次任务主要的贡献是一个简单又有力的接口，它能够自动地进行大规模分布式并行计算，与其实现相结合可以高效地完成大量PC机并行计算。</p><h3 id="context1at1457005060">2.程序模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;计算通过一个输入键值对集合生成一个输出键值对集合，MapReduce库将其表示为两个函数：Map和Reduce。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;用户编写Map时，通过输入键值对生成中间键值对，MapReduce库把所有拥有相同键I的值打组后传递给Reduce函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;用户编写Reduce时，接收键I以及它的值，把这些值混合成一个尽可能小的集合。通常每次调用Reduce只会生成0个或者1个值。提供给用户Reduce函数的这些中间值集合的是一个迭代器。它允许我们处理那些超过内存大小的列表数据。</p><h4>2.1 例子</h4><p>&nbsp; &nbsp; 考虑一个计算在一个文档的大集合里面出现每一个词的数量问题，用户只要轻松的写如下伪代码：</p><pre class="line-numbers  language-pseudo"><code class="  language-pseudo">map(String key,String value):<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">  // key: document  name<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">  // value: document contents <span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">  for each word w in value:<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">    EmitIntermediate(w,"1");<span class="line-numbers-rows"><span></span></span></code></pre><p><br></p><pre class="line-numbers  language-pseudo"><code class="  language-pseudo">reduce(String key, Iterator values):<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> // key: a word<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> // values: a list of counts<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> int result = 0;<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> for each v in values:<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo">   result += ParseInt(v);<span class="line-numbers-rows"><span></span></span></code><br><code class="  language-pseudo"> Emit(AsString(result));<span class="line-numbers-rows"><span></span></span></code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;map函数发送每一个word加上一个与之相连的数字（例子中给的是1）。reduce函数合计所有发射来的数字。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;另外，用户把输入和输出文件的名字也写进代码，之后调用MapReduce函数，传入一个专用的对象，用户的代码就与MapReduce库链接在了一起。附录A带有所有代码示例。</p><h4>2.2 类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;即使之前的伪代码是一个字符串的输入输出模式，讲道理给用户提供的map和reduce函数具有相关的类型：</p><p>&nbsp; &nbsp; map (k1, v1)&nbsp;&nbsp;&nbsp;&nbsp;-&gt; list (k2, v2)</p><p>&nbsp; &nbsp; reduce (k2, list(v2))&nbsp; &nbsp; -&gt; list (v2)</p><p>&nbsp; &nbsp; 换言之，输入的键值对和输出的键值对取自不同的作用域。同时，中间键值对和输出键值对在同一个作用域。</p><p>&nbsp; &nbsp; 我们用c++从用户定义的函数传递出字符串到用户的编码，让其在字符串和预定类型之间相互转换。</p><h4>2,.3 更多例子</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这里有一些简单有趣的例子，能够很容易用MapReduce计算表现。</p><p>&nbsp; &nbsp; <b>分布式检索</b>：map函数发射一条<span style="line-height: 1.42857143;">匹配所提供的模式的</span><span style="line-height: 1.42857143;">线，reduce函数是一个恒等映射，它只是把中间数据复制作为输出。</span></p><p>&nbsp; &nbsp; <b>URL访问频率计数</b>：map函数处理网页请求日志，然后输出&lt;URL,1&gt;。reduce函数把所有URL相同的值求和发射一个键值对&lt;URL,total count&gt;。</p><p>&nbsp; &nbsp; <b>翻转网页链接图</b>：map函数输出&lt;target,source&gt;键值对，在每个页面上找到的URL<span style="line-height: 1.42857143;">为</span>target的<span style="line-height: 1.42857143;">链接名称为source。reduce函数把所有原URL连成链表，与给出的目的URL关联，发送键值对&lt;target,list(source)&gt;。</span></p><p>&nbsp; &nbsp; <b>多主机词项向量</b>：一个词项向量把一个或多个文档中出现的最重要的单词总和成一个&lt;word,frequency&gt;键值对列表，map函数<span style="line-height: 1.42857143;">为每个输入文档</span><span style="line-height: 1.42857143;">发射一个&lt;hostname,term vector&gt;键值对（其中hostname是从文档 的URL中提取）。reduce函数为每个hostname传递所有的每份文件的词项向量。把这些词项向量添加在一起，去掉不频繁的词项，之后发送一个最终的&lt;hostname,term verctor&gt;键值对 。</span></p><p>&nbsp; &nbsp; <b>倒排索引</b>：map函数解析每个文档，发送一个&lt;word,document ID&gt;键值对序列。reduce方法接受所有的键值对，对指定word的键值对按对应的问倒ID进行排序，然后发送一个 &lt;word,list(document ID)&gt;键值对。所有的输出键值对形成 一个简单的倒序索引。很容易增强计算来保持对word位置的跟踪。</p><p>&nbsp; &nbsp; 分布式排序：map函数从每个record中提取key，然后发送一个&lt;key,record&gt;键值对。reduce函数发送所有无变化的键值对。这些计算都依靠区分设备（在4.1章会讲到）和属性描述整理（在4.2章会讲到）。</p><h3>3.实现</h3><p>很多不同的</p><p></p>